name: Daily Security Scan & Lint

on:
  schedule:
    - cron: '0 2 * * *' # daily at 02:00 UTC
  workflow_dispatch: {}

permissions:
  contents: read
  packages: read

jobs:
  discover-images:
    name: Discover GHCR Container Images
    runs-on: self-hosted
    outputs:
      images: ${{ steps.set.outputs.images }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Discover container packages and tags
        id: set
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OWNER: ${{ github.repository_owner }}
        run: |
          set -euo pipefail
          OWNER=${OWNER}
          TOKEN=${GITHUB_TOKEN:-}

          # Use Authorization header only when a token is available, so this can run without secrets for public packages
          if [ -n "$TOKEN" ]; then
            AUTH_HEADER=( -H "Authorization: token ${TOKEN}" -H "Accept: application/vnd.github+json" )
          else
            AUTH_HEADER=()
          fi

          # Try orgs endpoint first, fall back to users (both may be unauthenticated)
          PKG_API="https://api.github.com/orgs/${OWNER}/packages?package_type=container"
          PKGS=$(curl -s "${AUTH_HEADER[@]}" "${PKG_API}" || true)
          if [ "$(echo "$PKGS" | jq -r 'if type=="array" then "ok" else "no" end')" != "ok" ]; then
            PKG_API="https://api.github.com/users/${OWNER}/packages?package_type=container"
            PKGS=$(curl -s "${AUTH_HEADER[@]}" "${PKG_API}" || true)
          fi

          IMAGES="[]"
          for pkg in $(echo "$PKGS" | jq -r '.[].name' 2>/dev/null || true); do
            # list versions for package (use users endpoint per-midi-release style)
            VERSIONS_API="https://api.github.com/users/${OWNER}/packages/container/${pkg}/versions"
            VERSIONS=$(curl -s "${AUTH_HEADER[@]}" "${VERSIONS_API}" || true)
            for tag in $(echo "$VERSIONS" | jq -r '.[].metadata.container.tags[]' 2>/dev/null || true); do
              img="ghcr.io/${OWNER}/${pkg}:${tag}"
              IMAGES=$(jq -c --arg img "$img" '. + [$img]' <<< "$IMAGES")
            done
          done

          # dedupe
          IMAGES=$(jq -c 'unique' <<< "$IMAGES")
          echo "images=$IMAGES" >> $GITHUB_OUTPUT

  trivy-scan:
    name: Scan GHCR Images (Trivy)
    needs: discover-images
    runs-on: [self-hosted, runner-2]
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.discover-images.outputs.images) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Trivy (install and enable local cache)
        uses: aquasecurity/setup-trivy@v0.3.0
        with:
          cache: true
          # pin a reasonably recent version; runner can override by pre-installing
          version: v0.69.1

      - name: Scan image with Trivy
        uses: aquasecurity/trivy-action@v0.34.0
        with:
          image-ref: ${{ matrix.image }}
          format: 'table'
          # Tell the action not to run setup (we already ran setup-trivy)
          skip-setup-trivy: 'true'
          # Use a persistent cache directory on the runner to avoid repeated DB downloads
          cache-dir: '/var/lib/trivy'
        env:
          # If you pre-populate /var/lib/trivy on the runner, avoid downloading DBs here
          TRIVY_SKIP_DB_UPDATE: 'true'
          TRIVY_SKIP_JAVA_DB_UPDATE: 'true'
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  lint:
    name: Lint Code (data, db, midi, ui)
    needs: discover-images
    runs-on: [self-hosted, runner-2]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run folder lint commands
        run: |
          set -euo pipefail
          for d in data db midi ui; do
            echo "--- Lint: $d ---"
            if [ -f "$d/Makefile" ] && grep -q "^lint" "$d/Makefile"; then
              echo "Running make -C $d lint"
              make -C "$d" lint || true
            else
              # Try some sensible defaults per-language
              if [ -f "$d/go.mod" ]; then
                echo "Running go vet and go test for $d"
                (cd "$d" && go vet ./... || true)
                (cd "$d" && go test ./... || true)
              elif ls "$d"/*.csproj >/dev/null 2>&1; then
                echo "Running dotnet build for $d"
                (cd "$d" && curl -sSL https://dot.net/v1/dotnet-install.sh | bash /dev/stdin --channel 8.0 --install-dir $HOME/.dotnet || true)
                export PATH="$HOME/.dotnet:$PATH"
                (cd "$d" && $HOME/.dotnet/dotnet build || true)
              elif [ -f "$d/requirements.txt" ] || [ -f "$d/setup.py" ]; then
                echo "Running flake8 for $d if available"
                if command -v flake8 >/dev/null 2>&1; then
                  flake8 "$d" || true
                else
                  echo "flake8 not installed; skipping python lint for $d"
                fi
              else
                echo "No lint target or known language for $d; skipping"
              fi
            fi
          done
