name: Reusable Release

on:
  workflow_call:
    inputs:
      component:
        description: 'Component name (matches directory: db, data, midi, ui)'
        required: true
        type: string
      version-file:
        description: 'Path to version file relative to component directory'
        required: false
        type: string
        default: 'version.txt'
      build-target:
        description: 'Make target for building (e.g., build, build-image)'
        required: false
        type: string
        default: 'build'
      test-target:
        description: 'Make target for testing (empty to skip)'
        required: false
        type: string
        default: ''
      lint-target:
        description: 'Make target for linting (empty to skip)'
        required: false
        type: string
        default: ''
      package-target:
        description: 'Make target for packaging (empty to skip)'
        required: false
        type: string
        default: ''
      deploy-target:
        description: 'Make target for deployment'
        required: true
        type: string
      requires-docker-login:
        description: 'Whether component requires Docker/GHCR authentication'
        required: false
        type: boolean
        default: true
    secrets:
      component-secrets:
        description: 'JSON object of component-specific secrets to pass as environment variables'
        required: false

jobs:
  lint:
    name: Lint
    runs-on: self-hosted
    if: false # Disabled - too slow on RPi
    defaults:
      run:
        working-directory: ./${{ inputs.component }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Run Lint
        run: make ${{ inputs.lint-target }}

  test:
    name: Test
    runs-on: self-hosted
    needs: [build]
    if: inputs.test-target != '' && needs.build.outputs.needs-build == 'true'
    defaults:
      run:
        working-directory: ./${{ inputs.component }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Run Tests
        run: make ${{ inputs.test-target }}

  build:
    name: Build and Package
    runs-on: self-hosted
    needs: [lint]
    if: always() && (needs.lint.result == 'success' || needs.lint.result == 'skipped')
    permissions:
      packages: write
      security-events: write
    defaults:
      run:
        working-directory: ./${{ inputs.component }}
    outputs:
      version: ${{ steps.version.outputs.version }}
      namespace: ${{ steps.namespace.outputs.namespace }}
      needs-build: ${{ steps.check-artifact.outputs.needs-build }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Read Version
        id: version
        run: |
          VERSION=$(cat ${{ inputs.version-file }})
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Set Namespace Based on Branch
        id: namespace
        run: |
          if [[ "${{ github.ref_name }}" == "main" ]]; then
            NAMESPACE="eightbitsaxlounge-prod"
          else
            NAMESPACE="eightbitsaxlounge-dev"
          fi
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV

      - name: Check if artifact exists
        id: check-artifact
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          IMAGE="ghcr.io/${{ github.repository_owner }}/eightbitsaxlounge-${{ inputs.component }}:${VERSION}"
          echo "Checking if artifact exists: $IMAGE"
          echo "Looking for version tag: $VERSION"
          
          # Use GitHub Packages API to check if the version exists
          # This is more reliable than the Docker registry API
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/users/${{ github.repository_owner }}/packages/container/eightbitsaxlounge-${{ inputs.component }}/versions")
          
          echo "API Response Code: $RESPONSE"
          
          if [ "$RESPONSE" = "200" ]; then
            # Get the list of versions and check if our version exists
            VERSION_EXISTS=$(curl -s \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/users/${{ github.repository_owner }}/packages/container/eightbitsaxlounge-${{ inputs.component }}/versions" \
              | jq -r --arg ver "$VERSION" '.[] | .metadata.container.tags[] | select(. == $ver)' | head -n 1)
            
            echo "Found matching tag: '$VERSION_EXISTS'"
            
            if [ -n "$VERSION_EXISTS" ]; then
              echo "needs-build=false" >> $GITHUB_OUTPUT
              echo "✓ Artifact exists - will skip build and tests"
            else
              echo "needs-build=true" >> $GITHUB_OUTPUT
              echo "✗ Artifact not found - will build and test"
            fi
          else
            # If we can't access the API (404, 403, etc.), assume it doesn't exist and build
            echo "needs-build=true" >> $GITHUB_OUTPUT
            echo "✗ Could not check artifact (HTTP $RESPONSE) - will build and test"
          fi

      - name: Log in to GitHub Container Registry
        if: inputs.requires-docker-login && steps.check-artifact.outputs.needs-build == 'true'
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build
        if: steps.check-artifact.outputs.needs-build == 'true'
        env:
          VERSION: ${{ steps.version.outputs.version }}
          NAMESPACE: ${{ steps.namespace.outputs.namespace }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
        run: make ${{ inputs.build-target }}

      - name: Security Scan Container
        if: false # Disabled - too slow on RPi
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'ghcr.io/${{ github.repository_owner }}/eightbitsaxlounge-${{ inputs.component }}:${{ steps.version.outputs.version }}'
          format: 'sarif'
          output: '${{ inputs.component }}/trivy-results.sarif'

      - name: Upload Trivy Results to GitHub Security
        if: false # Disabled - too slow on RPi
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: '${{ inputs.component }}/trivy-results.sarif'

      - name: Package
        if: inputs.package-target != '' && steps.check-artifact.outputs.needs-build == 'true'
        env:
          VERSION: ${{ steps.version.outputs.version }}
          NAMESPACE: ${{ steps.namespace.outputs.namespace }}
        run: make ${{ inputs.package-target }}

  deploy:
    name: Deploy
    runs-on: self-hosted
    needs: [build, test]
    if: always() && inputs.deploy-target != '' && needs.build.result == 'success' && (needs.test.result == 'success' || needs.test.result == 'skipped')
    defaults:
      run:
        working-directory: ./${{ inputs.component }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Deploy
        env:
          VERSION: ${{ needs.build.outputs.version }}
          NEEDS_BUILD: ${{ needs.build.outputs.needs-build }}
          NAMESPACE: ${{ needs.build.outputs.namespace }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
          SECRETS_JSON: ${{ secrets.component-secrets }}
        run: |
          # Parse component-specific secrets from JSON and export as env vars
          if [[ -n "$SECRETS_JSON" ]]; then
            while IFS="=" read -r key value; do
              export "$key=$value"
            done < <(echo "$SECRETS_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"')
          fi
          
          make ${{ inputs.deploy-target }}
        shell: bash
