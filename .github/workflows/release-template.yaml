name: Reusable Release

on:
  workflow_call:
    inputs:
      component:
        description: 'Component name (matches directory: db, data, midi, ui)'
        required: true
        type: string
      version-file:
        description: 'Path to version file relative to component directory'
        required: false
        type: string
        default: 'version.txt'
      build-target:
        description: 'Make target for building (e.g., build, build-image)'
        required: false
        type: string
        default: 'build'
      test-target:
        description: 'Make target for testing (empty to skip)'
        required: false
        type: string
        default: ''
      lint-target:
        description: 'Make target for linting (empty to skip)'
        required: false
        type: string
        default: ''
      package-target:
        description: 'Make target for packaging (empty to skip)'
        required: false
        type: string
        default: ''
      deploy-target:
        description: 'Make target for deployment'
        required: true
        type: string
      requires-docker-login:
        description: 'Whether component requires Docker/GHCR authentication'
        required: false
        type: boolean
        default: true
    secrets:
      component-secrets:
        description: 'JSON object of component-specific secrets to pass as environment variables'
        required: false

jobs:
  lint:
    name: Lint
    runs-on: self-hosted
    if: inputs.lint-target != ''
    defaults:
      run:
        working-directory: ./${{ inputs.component }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Run Lint
        run: make ${{ inputs.lint-target }}

  test:
    name: Test
    runs-on: self-hosted
    needs: [lint]
    if: always() && (needs.lint.result == 'success' || needs.lint.result == 'skipped') && inputs.test-target != ''
    defaults:
      run:
        working-directory: ./${{ inputs.component }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Run Tests
        run: make ${{ inputs.test-target }}

  build:
    name: Build and Package
    runs-on: self-hosted
    needs: [lint, test]
    if: always() && (needs.lint.result == 'success' || needs.lint.result == 'skipped') && (needs.test.result == 'success' || needs.test.result == 'skipped')
    permissions:
      packages: write
      security-events: write
    defaults:
      run:
        working-directory: ./${{ inputs.component }}
    outputs:
      version: ${{ steps.version.outputs.version }}
      namespace: ${{ steps.namespace.outputs.namespace }}
      version-changed: ${{ steps.check-version.outputs.changed }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          fetch-depth: 2

      - name: Check if version changed
        id: check-version
        run: |
          if git diff HEAD^ HEAD --name-only | grep -q "^${{ inputs.component }}/${{ inputs.version-file }}$"; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Version file changed - will build"
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "Version file unchanged - will skip build"
          fi

      - name: Read Version
        id: version
        run: |
          VERSION=$(cat ${{ inputs.version-file }})
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Set Namespace Based on Branch
        id: namespace
        run: |
          if [[ "${{ github.ref_name }}" == "main" ]]; then
            NAMESPACE="eightbitsaxlounge-prod"
          else
            NAMESPACE="eightbitsaxlounge-dev"
          fi
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        if: inputs.requires-docker-login && steps.check-version.outputs.changed == 'true'
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build
        if: steps.check-version.outputs.changed == 'true'
        env:
          VERSION: ${{ steps.version.outputs.version }}
          NAMESPACE: ${{ steps.namespace.outputs.namespace }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
        run: make ${{ inputs.build-target }}

      - name: Security Scan Container
        if: inputs.requires-docker-login && steps.check-version.outputs.changed == 'true'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'ghcr.io/${{ github.repository_owner }}/eightbitsaxlounge-${{ inputs.component }}:${{ steps.version.outputs.version }}'
          format: 'sarif'
          output: '${{ inputs.component }}/trivy-results.sarif'

      - name: Upload Trivy Results to GitHub Security
        if: inputs.requires-docker-login && steps.check-version.outputs.changed == 'true' && always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: '${{ inputs.component }}/trivy-results.sarif'

      - name: Package
        if: inputs.package-target != '' && steps.check-version.outputs.changed == 'true'
        env:
          VERSION: ${{ steps.version.outputs.version }}
          NAMESPACE: ${{ steps.namespace.outputs.namespace }}
        run: make ${{ inputs.package-target }}

  deploy:
    name: Deploy
    runs-on: self-hosted
    needs: [build]
    defaults:
      run:
        working-directory: ./${{ inputs.component }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Deploy
        env:
          VERSION: ${{ needs.build.outputs.version }}
          NAMESPACE: ${{ needs.build.outputs.namespace }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
          SECRETS_JSON: ${{ secrets.component-secrets }}
        run: |
          # Parse component-specific secrets from JSON and export as env vars
          if [[ -n "$SECRETS_JSON" ]]; then
            while IFS="=" read -r key value; do
              export "$key=$value"
            done < <(echo "$SECRETS_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"')
          fi
          
          make ${{ inputs.deploy-target }}
        shell: bash
